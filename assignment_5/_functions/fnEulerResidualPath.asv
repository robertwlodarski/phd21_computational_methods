function [Residuals]        = fnEulerResidualPath(vKGuess,vAPath,KT, Parameters,Grids)

%% 1. Parameters

pSigma              = Parameters.pSigma;
pAlpha              = Parameters.pAlpha;
pChi                = Parameters.pChi;
pMu                 = Parameters.pMu;
pEta                = Parameters.pEta;
pDelta              = Parameters.pDelta;

% Grids
vGridK              = Grids.vWealthGrid;

% For Euler
    Psi_1               = @(K,Kp) -pMu * (Kp-K) / (K) - Adjustment(K,Kp) / K;
    Psi_2               = @(K,Kp) pMu * (Kp - K) / K;
    ValueDerivative     = @(N,K,Kp) BCConsumption(N,K,Kp)^(-pSigma) * (1 + Interest(N,K) - Psi_1(K,Kp));
    EulerError          = @(N,K,Kp,Np,Kpp) BCConsumption(N,K,Kp)^(-pSigma) * (1 + Psi_2(K,Kp)) - pBeta *  ValueDerivative(Np,Kp,Kpp);

% Other key items
pT              = size(vKGuess);
VKGuessExpanded = [vKGuess; KT; KT];

%% 2. Run the loop
for ttt = 1:1:pT
    
    % A. K, Kp, and Kpp
    K               = VKGuessExpanded(ttt);
    Kp              = VKGuessExpanded(ttt+1);
    Kpp             = VKGuessExpanded(ttt+2);
    A               = vAPath(ttt);  

    % B. Key values
    [Np,Cp,Rp,Wp]   = fnFindNTransitions(K,Kp,A,Parameters);
    [Np,Cp,Rp,Wp]   = fnFindNTransitions(K,Kp,A,Parameters);


end 

end 