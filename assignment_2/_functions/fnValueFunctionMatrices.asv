function [mV,mS,mW,mN]      = fnValueFunctionMatrices(Parameters,Grids)
    % Unpack the key elements
    pEta                    = Parameters.pEta;
    pBeta                   = Parameters.pBeta;
    pr                      = Parameters.pr;
    pb                      = Parameters.pb;
    pVarphi                 = Parameters.pVarphi;
    pPhi                    = Parameters.pPhi;
    pT                      = Parameters.pT;
    vGridZ                  = Grids.vGridZ;
    vGridH                  = Grids.vGridH;
    vGrida                  = Grids.vGrida;
    vGridAge                = Grids.vGridAge;
    mTransition             = Grids.mTransitionZ;
    pPenalty                = 0;

    % Initialise value function matrices
    % (a,h,z,T,a')
    mV                      = zeros(size(vGrida,1),size(vGridH,1),size(vGridZ,1),size(vGridAge,1));
    mS                      = mV;
    mW                      = mS;
    mN                      = mW;

    % Solve for T=50
    for aaa = 1:1:size(vGrida,1)
        for hhh = 1:1:size(vGridH,1)
            for zzz = 1:1:size(vGridZ,1)
                    % Wages, assets and human capital
                    h           = vGridH(hhh);
                    a           = vGrida(aaa);
                    z           = vGridZ(zzz);
                    w           = fnWage(h,z,Parameters);
                    % Working household
                    a_next_w    = (pBeta/(pBeta+1))*(w + (1+pr)*a);
                    a_next_w    = max(a_next_w, 1e-9);
                    c_w         = w + (1+pr)*a-a_next_w;
                    c_w         = max(c_w, 1e-9);
                    W           = log(c_w) - pEta + pBeta * log(a_next_w);
                    % Non-working household
                    a_next_n    = (pBeta/(pBeta+1))*(pb + (1+pr)*a);
                    a_next_n    = max(a_next_n,1e-9);
                    c_n         = pb + (1+pr)*a-a_next_n;
                    c_n         = max(c_n,1e-9);
                    N           = log(c_n) + pBeta * log(a_next_n); 
                    % Value functions
                    V           = fnGumbelTrick(W,N,Parameters);
                    arg1        = pVarphi * W + (1 - pVarphi) * N - pPhi;
                    S           = fnGumbelTrick(arg1,N,Parameters);
                    % Save the "incorrect choice" results
                    mV(aaa,hhh,zzz,pT+1) = V;
                    mS(aaa,hhh,zzz,pT+1) = S;
                    mW(aaa,hhh,zzz,pT+1) = W;
                    mN(aaa,hhh,zzz,pT+1) = N;
            end
        end 
    end

    % Initialise interpolation functions
    X_inter                 = @(a_prime, h_prime, X) interpn(vGrida, vGridH, X, a_prime, h_prime); 
    
    % Solve for the remaining times (backward)
    for ttt=pT:(-1):1                               % Time
        
        for aaa = 1:1:size(vGrida,1)                % Existing wealth
            for hhh = 1:1:size(vGridH,1)            % Human capital
                for zzz = 1:1:size(vGridZ,1)        % Productivity
                        % Wages, assets and human capital
                        h_fut           = min(size(vGridH,1),hhh+1);
                        h               = vGridH(hhh);
                        a               = vGrida(aaa);
                        z               = vGridZ(zzz);
                        w               = fnWage(h,z,Parameters);
                        BC_w            = (1+pr)*a + w;
                        BC_n            = (1+pr)*a + pb;
                        % Add wealth bounds (upper)
                        a_next_up_w     = BC_w;
                        a_next_up_n     = BC_n;
                        % Set functions
                        Obj_W           = @(x) -(log(BC_w - x) - pEta + pBeta * (mTransition(zzz,:) * squeeze(X_inter(x,h_fut,mW(:,:,:,ttt+1)))));
                        Obj_N           = @(x) -(log(BC_n - x) + pBeta * (mTransition(zzz,:) * squeeze(X_inter(x,h_fut,mN(:,:,:,ttt+1))))); 
                        % Solve for the wealth next period
                        [a_next_w,W]    = fminbnd(Obj_W,a_next_min_w,a_next_up_w);
                        [a_next_n,N]    = fminbnd(Obj_N,a_next_min_n,a_next_up_n);
                        W               = -W;
                        N               = -N;
                        % Update minimum wealth level 
                        a_next_min_w    = a_next_w;
                        a_next_min_n    = a_next_n;
                        % Value functions
                        V           = fnGumbelTrick(W,N,Parameters);
                        arg1        = pVarphi * W + (1 - pVarphi) * N - pPhi;
                        S           = fnGumbelTrick(arg1,N,Parameters);
                        % Save the results
                        mV(aaa,hhh,zzz,ttt) = V;
                        mS(aaa,hhh,zzz,ttt) = S;
                        mW(aaa,hhh,zzz,ttt) = W;
                        mN(aaa,hhh,zzz,ttt) = N;
                end 
            end 
        end 
    end

end