function Results        = fnUncertaintyEquilibrium(Parameters,Grids, ResultSS)

%% 1. Prepare the setting

% Parameters
pEta                = Parameters.pEta;
pAlpha              = Parameters.pAlpha;
pDelta              = Parameters.pDelta;
pGamma              = Parameters.pGamma;
pBeta               = Parameters.pBeta;
pPhi                = Parameters.pPhi;

% Grids
vGridA              = Grids.vGridTFP;
vGridK              = Grids.vGridK;
mTransitionA        = Grids.mTransitionTFP;

% Set-up elements
rng(1997);
pT                  = 10000;
pBurnIn             = 500;
pRequiredTime       = pT + pBurnIn;
iError              = 10;
pErrorTol           = 1e-4;
pStepSize           = 0.99;
iIterationNum       = 1;

% Set up productivity shocks
vAShock             = rand(pRequiredTime,1);
vAIndex             = zeros(pRequiredTime,1);
vAIndex(1)          = 4;
for ttt = 2:1:pRequiredTime
    vAIndex(ttt)    = sum(vAShock(ttt) >= cumsum(squeeze(mTransitionA(vAIndex(ttt-1),:))))+1;
end 
vApIndex            = [vAIndex(2:end);vAIndex(1)];
vA                  = vGridA(vAIndex);
vAp                 = vGridA(vApIndex);
vRealisedP          = zeros(pRequiredTime,1);
for ttt = 1:1:pRequiredTime
    vRealisedP(ttt) = mTransitionA(vAIndex(ttt),vApIndex(ttt));
end

%% 2. Initial guesses

% Guess capital (with minor pertubation) and consumption
vK                  = max(ResultSS.K * ones(pRequiredTime,1) + normrnd(0,1e-8,pRequiredTime,1),1e-8);
vC                  = ResultSS.C * ones(pRequiredTime,1);
vIMin               = pPhi * pDelta * ResultSS.K;

% Steady state value function
vJ1SS               = pAlpha * Results 

%% 3. Start running the loop
tic;
while iError > pErrorTol
    fprintf('Iteration:             %.0f \n', iIterationNum);

    % Implied elements calculation
    vW                          = pEta * vC;
    vKp                         = [vK(2:end);vK(1)];
    vN                          = ((pGamma * vA .* vK.^(pAlpha))./vW).^(1 / (1-pGamma));
    vNp                         = [vN(2:end);vN(1)];
    vCp                         = [vC(2:end);vC(1)];

    %% 4. Backward simulation begins
    
    % 4.1. Initialise the expected marginal value
    mEJ1                        = 0.0;

    % 4.2. Open the TFP loop
    for iApIndex = 1:1:size(vGridA,1)
        
        %% 5. Find the "neighbours"
        % A. Look for candidates
        Ap                                      = vGridA(iApIndex);
        iCandidateLoc                           = find(vA == Ap);

        % B. Clean "forbidden" candidates & sort
        iCandidateLoc(iCandidateLoc<pBurnIn)    = [];
        iCandidateLoc(iCandidateLoc>pT)         = [];
        iCandidate                              = vK(iCandidateLoc);
        [iCandidate, iIndex]                    = sort(iCandidate);
        iCandidateLoc                           = iCandidateLoc(iIndex);

        % C. Extrapolation setting
        iEdges                                  = [-Inf; iCandidate; Inf];
        iBinIndices                             = discretize(vKp, iEdges);
        iKLow                                   = iBinIndices -1;
        iKLow(iKLow < 1)                        = 1;
        iKLow(iKLow >= length(iIndex))          = length(iIndex)-1;
        iKHigh                                  = iKLow + 1;
        iIndLow                                 = iCandidateLoc(iKLow);
        iIndHigh                                = iCandidateLoc(iKHigh);
        iWeightLow                              = (vK(iIndLow) - vKp) ./ (vK(iIndHigh) - vK(iIndLow));
        iWeightLow(iWeightLow < 0)              = 0;
        iWeightLow(iWeightLow > 1)              = 1;

        % D. Get MPK values for unconstrained solution
        iInnerTermLow                           = 1; %Replace with a guess
        iInnerTermHigh                          = 1; %Replace with a guess
        iInnerInterpolated                      = iWeightLow .* iInnerTermLow + (1 - iWeightLow) .* iInnerTermHigh;
        mEJ1                                    = mEJ1 + (vAp ~= Ap) .* mTransitionA(vAIndex,iApIndex) .* iInnerInterpolated;

        % Close the TFP loop
    end 

    % E. Add the realised path
    mEJ1                        = mEJ1 + vRealisedP .* iInner;
    
    %% 6. Update the allocations

    % 6.1. Unconstrained allocation
    vY                          = vA .* vK.^(pAlpha) .* vN.^(pGamma);
    vCUnc                       = 1 ./ mEJ1;
    vKpUnc                      = vY + (1 - pDelta) .* vK - vCUnc;

    % 6.2. Add constraints and obtain implied K and C
    vKpMin                      = vIMin + (1-pDelta)*vK;
    vKpImplied                  = max(vKpMin,vKpUnc);
    vCImplied                   =  vY + (1 - pDelta) .* vK - vKpImplied;
    
    % 6.3. Compute the inner term

    %% 7. Finalise the loop

    iIterationNum               = iIterationNum + 1;
    % Close the outer loop
end 
toc;