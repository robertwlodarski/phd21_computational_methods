function Results        = fnUncertaintyEquilibrium(Parameters,Grids, ResultSS)

%% 1. Prepare the setting

% Parameters
pEta                = Parameters.pEta;


% Grids
vGridA              = Grids.vGridTFP;
vGridK              = Grids.vGridK;
mTransitionA        = Grids.mTransitionTFP;

% Set-up elements
rng(1997);
pT                  = 10000;
pBurnIn             = 500;
pRequiredTime       = pT + pBurnIn;
iError              = 10;
pErrorTol           = 1e-4;
pStepSize           = 0.99;
iIterationNum       = 1;

% Set up productivity shocks
vAShock             = rand(pRequiredTime,1);
vAIndex             = zeros(pRequiredTime,1);
vAIndex(1)          = 4;
for ttt = 2:1:pRequiredTime
    vAIndex(ttt)    = sum(vAShock(ttt) >= cumsum(squeeze(mTransitionA(vAIndex(ttt-1),:))))+1;
end 
vApIndex            = [vAIndex(2:end);vAIndex(1)];
vA                  = vGridA(vAIndex);
vAp                 = vGridA(vApIndex);
vRealisedP          = zeros(pRequiredTime,1);
for ttt = 1:1:pRequiredTime
    vRealisedP(ttt) = mTransitionA(vAIndex(ttt),vApIndex(ttt));
end

%% 2. Initial guesses

% Guess capital (with minor pertubation) and consumption
vK                  = max(ResultSS.K * ones(pRequiredTime,1) + normrnd(0,1e-8,pRequiredTime,1),1e-8);
vC                  = ResultSS.C * ones(pRequiredTime,1);


%% 3. Start running the loop
tic;
while iError > pErrorTol
     fprintf('Iteration:             %.0f \n', iIterationNum);

     %% 4. Compute the implied prices
     vW                         = pEta * vC;
     vKp
    
     iIterationNum              = iIterationNum + 1;
     % Close the outer loop
end 
toc;