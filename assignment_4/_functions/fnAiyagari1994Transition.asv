function [Results]          = fnAiyagari1994Transition(Start,End,Parameters,Grids)

%% 1. Unpacking
% Parameters
ParametersUsed          = Parameters;
pT                      = Parameters.pT;
pAlpha                  = ParametersUsed.pAlpha;
pDelta                  = ParametersUsed.pDelta;
pBeta                   = ParametersUsed.pBeta;

% Grids
vGridA1                 = Grids.vGridA1;
vGridA2                 = Grids.vGridA2;
vGridZ                  = Grids.vGridZ;
mTransitionZ            = Grids.mTransitionZ;

%% 2. Compute the initial and terminal equilibria

% Terminal state
ParametersUsed.pA       = End;
ResultsT                = fnSolveAiyagari1994Iteration(ParametersUsed,Grids);

% Initial state
ParametersUsed.pA       = Start;
Results0                = fnSolveAiyagari1994Iteration(ParametersUsed,Grids);

%% 3. Set-up
% Iterations business: Convergence, acceleration, and GE
iWeightOld              = 0.9;
iErrorK                 = 10;
iTolK                   = 1e-8;
iTolDist                = 1e-8;
iIterNumK               = 1;

%% 4. Stationary dist. of labour allocation
iErrorZDist             = 10;
iTolZDist               = 1e-8;
vZDist                  = ones(size(vGridZ,1),1) / sum( ones(size(vGridZ,1),1));
while iErrorZDist>iTolZDist
    vZDistNext          = mTransitionZ' * vZDist;
    iErrorZDist         = abs(vZDistNext-vZDist);
    vZDist              = vZDistNext; 
end
vLabSupply              = vGridZ'*vZDist;

%% 5. TRANSITIONAL DYNAMICS

% Capital guess
A_guess                 = linspace(Start,End,pT);               

% Initialise values
iCurrentDistribution    = ResultsT.mDistribution;
iValueNext              = ResultsT.mValue;

while iErrorK > iTolK
    % Compute endogenous objects
    iInterest               = pAlpha * pA * (GuessK / vLabSupply)^(pAlpha - 1) - pDelta;
    iWage                   = (1 - pAlpha) * pA * (GuessK / vLabSupply)^(pAlpha);

    %% 5.1. Value & policy functions
    for ttt = pT:(-1):1
        
        % A. Matrices: Value function, policy functions
        mPolicyWealthNext       = zeros(size(iValueNext));

        % Run the loop
        % Start iterating over z and a
        for zzz = 1:1:size(vGridZ,1)
            % Set z-related items
            iLabour                         = vGridZ(zzz);

            % Expected future values
            mExpectedValue                  = iValueNext * mTransitionZ';
            iExpValueZ                      = mExpectedValue(:,zzz);
            iMinWealth                      = vGridA1(1);

            for aaa = 1:1:size(vGridA1,1)

                % Current values
                iWealth                     = vGridA1(aaa);
                iBudget                     = iWage * iLabour + (1+iInterest) * iWealth;

                % Optimisation station
                iWealthNext                 = fnFastOptimisation(iBudget,iMinWealth,iExpValueZ,ParametersUsed,Grids);
                iWealthNext(iWealthNext<vGridA1(1)) ...
                    =vGridA1(1);
                iConsumption                = iBudget-iWealthNext;

                % Interpolate value function
                iWLow                       = min(max(sum(vGridA1<iWealthNext),1),size(vGridA1,1)-1);
                iWHigh                      = iWLow+1;
                iWeightLow                  = (vGridA1(iWHigh)-iWealthNext) / (vGridA1(iWHigh)-vGridA1(iWLow));
                iExpValue                   = iWeightLow*iExpValueZ(iWLow)+(1-iWeightLow)*iExpValueZ(iWHigh);
                iValue                      = log(iConsumption)+pBeta*iExpValue;

                % Updating
                mValueNew(aaa,zzz)          = iValue;
                mPolicyWealthNext(aaa,zzz)  = iWealthNext;
            end
        end

    end
    %% 5.2. Distributions (iteration method)

    %% 5.3. Aggregate and obtain K_new

    % End the equilibrium loop
end

end 