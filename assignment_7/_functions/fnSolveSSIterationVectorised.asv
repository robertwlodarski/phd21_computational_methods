function [Results]       = fnSolveSSIterationVectorised(Parameters,Grids)
tic; 

%% 1. Unpacking
% Parameters
pAlpha                  = Parameters.pAlpha;
pDelta                  = Parameters.pDelta;
pA                      = Parameters.pA;
pBeta                   = Parameters.pBeta;
pMu                     = Parameters.pMu;
pChi                    = Parameters.pChi;
pEta                    = Parameters.pEta;
pVerbose                = true;

% Grids
vGridA1                 = Grids.vGridA1;
vGridA2                 = Grids.vGridA2;
vGridZ                  = Grids.vGridZ;
mTransitionZ            = Grids.mTransitionZ;

%% 2. Stationary dist. of labour allocation
iErrorZDist             = 10;
iTolZDist               = 1e-8;
vZDist                  = ones(size(vGridZ,1),1) / sum( ones(size(vGridZ,1),1));
while iErrorZDist>iTolZDist
    vZDistNext          = mTransitionZ' * vZDist;
    iErrorZDist         = abs(vZDistNext-vZDist);
    vZDist              = vZDistNext; 
end

%% 3. Set-up
% Iterations business: Convergence, acceleration, and GE
iWeightOld              = 0.95;
iErrorGE                = 10;
iTolGE                  = 1e-5;
iTolPFI                 = 1e-5;
iTolDist                = 1e-5;
iIterNumGE              = 1;
iWeightPFI              = 0.65;

% Initial K guess
iK                      = 26.6 / sqrt(pEta);
iL                      = 0.94 / sqrt(pEta) *vGridZ'*vZDist;
iN                      = 0.94 / sqrt(pEta);
% Caution: iN = hours, iL = effective hours

% Other initialised elements
mPolicyWealthNext       = repmat(vGridA1,1,size(vGridZ,1));
mPolicyCons             = zeros(size(mPolicyWealthNext));
mPolicyLabour           = mPolicyWealthNext;
% Distributions
iCurrentDistribution    = ones(size(vGridA2,1),size(vGridZ,1)) / sum(sum(ones(size(vGridA2,1),size(vGridZ,1))));


%% 4. GE & PFI loops

% START GE LOOP
while iErrorGE>iTolGE
    % Derive K-related items
    iInterest           = pAlpha * pA * (iK / iL)^(pAlpha - 1) - pDelta;
    iWage               = (1 - pAlpha) * pA * (iK / iL)^(pAlpha);
    % Prepare for starting VFI loop
    iErrorPFI           = 10;
    iNumIterPFI         = 1;

    %% 4.1. START PFI LOOP
    while iErrorPFI > iTolPFI
       
        %% A. Interpolate mApp
        mA              = repmat(vGridA1,1,size(vGridZ,1));
        mAp             = mPolicyWealthNext;
        mApp            = zeros(size(mPolicyWealthNext));

        % Loop over the labout productivity grid
        for zzz = 1:1:size(vGridZ,1)
            mApp(:,zzz)         = interp1(vGridA1,mPolicyWealthNext(:,zzz),mPolicyWealthNext(:,zzz),'linear','extrap');
        end
        
        %% B. Use (Budget) and (Labour) to back out c' 
        % Remember that you're one period ahead
        mPsip           = pMu / 2 * (mApp.^2 ./ mAp - 2* mApp + mAp);
        mAAA            = (1+iInterest)*mAp - mApp - mPsip;
        mZ              = repmat(vGridZ',size(vGridA1,1),1);
        mBBB            = (iWage * mZ).^2 / pEta;
        mCp             = (sqrt(mAAA.^2 + 4* mBBB)+mAAA)/2;

        %% C. Get current optimal c
        mPsi1           = pMu * (mAp ./ mA -1);
        mDenominator    = 1 + mPsi1;
        mPsi2p          = pMu / 2 * (- (mApp./mAp).^2 + 1);
        mInnerTerm      = mCp.^(-1).*(1+iInterest-mPsi2p);
        mNumerator      = pBeta * mInnerTerm * mTransitionZ';
        mC              = (mNumerator ./ mDenominator).^(-1);

        %% D. New labour (things can only get better?)
        mN              = iWage * mZ ./ (mC * pEta);

        %% E. New policy
        mPsi            = pMu / 2 * (mAp.^2 ./ mA - 2* mAp + mA);
        mBudget         = (1+iInterest)*mA + iWage * mZ .* mN;
        mApNew          = mBudget-mPsi-mC;

        %% F. Update & compute error
        iErrorPFI           = max(abs(mApNew - mAp),[],"all");
        mPolicyWealthNext   = iWeightPFI .* mAp + (1-iWeightPFI).*mApNew;

        % Finish PFI here
    end

    %% 4.2. Wealth policy: More granular grid
    mPolicyWealthNext2              = zeros(size(iCurrentDistribution));

    % If both are the same
    if (size(vGridA1,1)==size(vGridA2,1))
        mPolicyWealthNext2          = mPolicyWealthNext;
    else 
    end

    % If both of them aren't the same
    for zzz = 1:1:size(vGridZ,1)
        mPolicyWealthNext2(:,zzz)   = interp1(vGridA1,mPolicyWealthNext(:,zzz),vGridA2,"linear","extrap");
    end

    % Save the implied value function [useful for transitional dynamics]
 
    %% 4.3. Iteration method
    
    % Initialise
    iErrorDist                     = 10;
    while iErrorDist > iTolDist
    iNextDistribution               = zeros(size(iCurrentDistribution));
    % Start iterating over z and a
    for zzz = 1:1:size(vGridZ,1)
        for aaa = 1:1:size(vGridA2,1)
            % Set up
            iWealth                         = vGridA2(aaa);
            iWealthNext                     = mPolicyWealthNext2(aaa,zzz);
            iLB                             = sum(vGridA2<iWealthNext);
            iLB(iLB<=0)                     = 1;
            iLB(iLB>=size(vGridA2,1))       = size(vGridA2,1)-1;
            iUB                             = iLB + 1;
            iWeightLB                       = (vGridA2(iUB)-iWealthNext) / (vGridA2(iUB)-vGridA2(iLB));
            iWeightLB(iWeightLB<0)          = 0;
            iWeightLB(iWeightLB>1)          = 1;
            iWeightUB                       = 1 - iWeightLB;
            iMass                           = iCurrentDistribution(aaa,zzz);

            % Iterate over future labour
            for zzp = 1:1:size(vGridZ,1)
                % Upper
                iNextDistribution(iUB,zzp)  = iNextDistribution(iUB,zzp) + iMass * mTransitionZ(zzz,zzp) * iWeightUB;
                % Lower
                iNextDistribution(iLB,zzp)  = iNextDistribution(iLB,zzp) + iMass * mTransitionZ(zzz,zzp) * iWeightLB;
            end
        end
    end
    % Save
    iErrorDist          = max(abs(iNextDistribution-iCurrentDistribution),[],"all");
    iCurrentDistribution=iNextDistribution;
    end

    % Update other elements
    mPolicyLabour2      = interp1(vGridA1, mPolicyLabour, vGridA2, 'linear', 'extrap');
    iEndoL              = vGridZ' * sum(iCurrentDistribution.*mPolicyLabour2,1)';
    iEndoN              = sum(iCurrentDistribution.*mPolicyLabour2,"all");
    iMarginalDist       = sum(iCurrentDistribution,2);
    iEndoK              = vGridA2' * iMarginalDist;
    iErrorGE            = max(abs(iEndoK - iK),abs(iEndoL - iL));
    iK                  = iK .* iWeightOld + iEndoK .* (1-iWeightOld);
    iN                  = iN .* iWeightOld + iEndoN .* (1-iWeightOld);
    iL                  = iL .* iWeightOld + iEndoL .* (1-iWeightOld);
    
    
    % Print cute messages 
    if (pVerbose == true && floor((iIterNumGE-1) / 25) == ((iIterNumGE-1) / 25) || iErrorGE < iTolGE)
        fprintf('======================================== \n')
        fprintf('             Iteration %.0f              \n',iIterNumGE);
        fprintf('======================================== \n')
        fprintf('SUMMARY \n')
        fprintf('Maximum error:     %.3f \n', iErrorGE);
        fprintf('Iterest rate:      %.3f \n', iInterest);
        fprintf('Wage:              %.3f \n', iWage);
        fprintf('IMPLIED VALUES \n')
        fprintf('K:                 %.3f \n', iEndoK);
        fprintf('L:                 %.3f \n', iEndoL);
        fprintf('N:                 %.3f \n', iEndoN);
        fprintf('NEW VALUES \n')
        fprintf('K:                 %.3f \n', iK);
        fprintf('L:                 %.3f \n', iL);
        fprintf('N:                 %.3f \n', iN);
        toc;
    else 
    end
    % END GE LOOP
    iIterNumGE          = iIterNumGE + 1;
end

%% Save results
Results.mDistribution       = iCurrentDistribution;
Results.vWage               = iWage;
Results.vInterest           = iInterest;
Results.vCapitalOpt         = iK;
Results.mPolicyWealthNext   = mPolicyWealthNext2;
Results.vLabourSupply       = iL;
Results.vHours              = iN;
Results.mValue              = mValue;

end


% ARCHIVE: VFI LOOP WTH GOLDEN SEARCH AND HOWARD ACCELERATOR [NOT WORKING]
% % Golden ratio settings
% pTolGR                  = 1e-8;
% pCGR1                   = (sqrt(5)-1)/2;
% pCGR2                   = (3-sqrt(5))/2;
% pIterNumTolGR           = 25;
% while iErrorVFI>iTolVFI
%
%     % Start iterating over z and a
%     for zzz = 1:1:size(vGridZ,1)
%         % Set z-related items
%         iLabourProd                 = vGridZ(zzz);
%
%         % Expected future values
%         mExpectedValue              = mValue * mTransitionZ';
%         iExpValueZ                  = mExpectedValue(:,zzz);
%         iMinWealth                  = vGridA1(1);
%
%         %% A. POLICY FUNCTIONS
%         % A1. Golden ratio algorithm
%         % Initial points
%         vApLB                   = repmat(vGridA1(1),size(vGridA1,1),1);
%         vApUBSafe               = (1+iInterest)*vGridA1 + iWage * iLabourProd * 5;
%         vApUB                   = min(repmat(vGridA1(end),size(vGridA1,1),1),vApUBSafe);
%
%         % Prohibit radical jumps for the Golden ratio algorithm
%         if iNumIterVFI >1
%             % For lower bound
%             vStepL              = 2;
%             vApLB               = max(vApLB,mPolicyWealthNext(:,zzz)-vStepL);
%             % For upper bound
%             vStepU              = 5;
%             vApUB               = min(vApUB,mPolicyWealthNext(:,zzz)+vStepU);
%             % Safety check
%             vApUB               = max(vApLB+1e-5,vApUB);
%         end
%
%         % Initial step
%         vApDiff                 = vApUB-vApLB;
%         vApMid1                 = vApLB+pCGR1*vApDiff;
%         vApMid2                 = vApLB+pCGR2*vApDiff;
%
%         % Simplify the function
%         fnObjective             = @(vAp,vA) fnVectorisedValues(vAp,vA,iLabourProd,iWage,iInterest,Parameters,Grids,iExpValueZ);
%         vVMid1                  = fnObjective(vApMid1,vGridA1);
%         vVMid2                  = fnObjective(vApMid2,vGridA1);
%
%         % Run the golden ratio algorithm
%         for iii = 1:1:pIterNumTolGR
%             % Identify better region
%             iIndexRegion            = (vVMid2 >= vVMid1);
%             vApLB(iIndexRegion)     = vApMid1(iIndexRegion);
%             vApUB(~iIndexRegion)    = vApMid2(~iIndexRegion);
%
%             % Update points [if vVMid1 >= vVmid2]
%             vApDiff(iIndexRegion)   = vApUB(iIndexRegion)-vApLB(iIndexRegion);
%             vApMid1(iIndexRegion)   = vApMid2(iIndexRegion);
%             vApMid2(iIndexRegion)   = vApLB(iIndexRegion)+pCGR2*vApDiff(iIndexRegion);
%             vVMid1(iIndexRegion)    = vVMid2(iIndexRegion);
%             vVMid2(iIndexRegion)    = fnObjective(vApMid2(iIndexRegion),vGridA1(iIndexRegion));
%
%             % Update points [if vVMid1 < vVmid2]
%             vApDiff(~iIndexRegion)  = vApUB(~iIndexRegion)-vApLB(~iIndexRegion);
%             vApMid2(~iIndexRegion)  = vApMid1(~iIndexRegion);
%             vApMid1(~iIndexRegion)  = vApLB(~iIndexRegion)+pCGR1*vApDiff(~iIndexRegion);
%             vVMid2(~iIndexRegion)   = vVMid1(~iIndexRegion);
%             vVMid1(~iIndexRegion)   = fnObjective(vApMid1(~iIndexRegion),vGridA1(~iIndexRegion));
%         end
%
%         % Save results from the optimisation step
%         vAp                         = (vApLB + vApUB) / 2;
%         [vV,vC,vN]                  = fnObjective(vAp,vGridA1);
%
%         % Updating
%         mValueNew(:,zzz)            = vV;
%         mPolicyCons(:,zzz)          = vC;
%         mPolicyWealthNext(:,zzz)    = vAp;
%         mPolicyLabour(:,zzz)        = vN;
%
%     end
%
%     %% B. HOWARD ACCELERATOR
%
%     % Compute the flow utility component
%     mFlowUtility                    = log(mPolicyCons) - pEta * mPolicyLabour .^(1 + 1 / pChi) / (1 + 1 / pChi);
%
%     % Run the accelerated version
%     if iNumIterVFI > iAccelerationStart % Let it solve properly a few times
%         for iii = 1:1:iAccelerationInterv
%             % Update the expected value
%             mExpectedValue                      = mValueNew * mTransitionZ';
%
%             % Compute the ever-changing continuation value
%             mContinuationValue                  = zeros(size(mValue));
%             for zzz = 1:1:size(vGridZ,1)
%                 mContinuationValue(:,zzz)       = interp1(vGridA1,mExpectedValue(:,zzz),mPolicyWealthNext(:,zzz),'linear','extrap');
%             end
%             mValueNew                           = mFlowUtility + pBeta * mContinuationValue;
%         end
%     end
%
%     %% C. UPDATING BUSINESS
%
%     % Update VFI loop items
%     iNumIterVFI                 = iNumIterVFI + 1;
%     iErrorVFI                   = max(abs(mValue-mValueNew),[],"all");
%     mValue                      = iWeightVFI*mValue + (1-iWeightVFI)*mValueNew;
%
%     if (pVerbose == true && floor((iNumIterVFI-1) / 50) == ((iNumIterVFI-1) / 50) || iErrorVFI < iTolVFI)
%     fprintf('--------------------------- \n')
%     fprintf('Iteration:         %.0f \n', iNumIterVFI);
%     fprintf('VFI error:         %.3f \n', iErrorVFI);
%     else
%     end
% end