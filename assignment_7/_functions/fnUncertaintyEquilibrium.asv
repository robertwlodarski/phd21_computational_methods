function [Results]          = fnUncertaintyEquilibrium(Parameters, Grids,Results0)

%% 1. Prepare key elements

% From parameters
pSigma              = Parameters.pSigma;
pEta                = Parameters.pEta;
pChi                = Parameters.pChi;
pBeta               = Parameters.pBeta;
pAlpha              = Parameters.pAlpha;
pDelta              = Parameters.pDelta;
pMu                 = Parameters.pMu;

% From grids
vGridA              = Grids.vGridTFP;
mTransitionA        = Grids.mTransitionTFP;
vGridZ              = Grids.vGridZ;
vGridA2             = Grids.vGridA2;

% Set-up elements
rng(1997);
pT                  = 10000;
pBurnIn             = 500;
pRequiredTime       = pT + pBurnIn;
iError2             = 10;
pErrorTol           = 1e-8;
vFuture             = [(2:pRequiredTime)'; pRequiredTime];
pStepSize           = 0.95;
iIterationNum       = 1;

% Set up productivity shocks
vAShock             = rand(pRequiredTime,1);
vAIndex             = zeros(pRequiredTime,1);
vAIndex(1)          = 4;
for ttt = 2:1:pRequiredTime
    vAIndex(ttt)    = sum(vAShock(ttt) >= cumsum(squeeze(mTransitionA(vAIndex(ttt-1),:))))+1;
end 
vApIndex            = [vAIndex(2:end);vAIndex(1)];
vA                  = vGridA(vAIndex);
vAp                 = vGridA(vApIndex);
vRealisedP          = zeros(pRequiredTime,1);
for ttt = 1:1:pRequiredTime
    vRealisedP(ttt) = mTransitionA(vAIndex(ttt),vApIndex(ttt));
end

%% 2. Initial guesses

% Initial guesses 
% Aggregate
vL                  = ones(pRequiredTime,1)*Results0.vLabourSupply;
vK                  = max(ones(pRequiredTime,1)*Results0.vCapitalOpt + normrnd(0,1e-8,pRequiredTime,1),1e-8);

% Policy function (C, Ap, and N)
mPolicyC                    = repmat(Results0.mC,1,1,pRequiredTime);
mPolicyN                    = repmat(Results0.mN,1,1,pRequiredTime);
mPolicyA2                   = repmat(Results0.mPolicyWealthNext,1,1,pRequiredTime);

%% 3. Start running the loop

% Start the outer loop
tic;
while iError2 > pErrorTol

    %% 4. Compute the price guesses
    vKtoL               = vK ./ vL;
    vInterest           = - pDelta + pAlpha * vA .* vKtoL.^(pAlpha-1);
    vWage               = (1-pAlpha) * vA .* vKtoL.^(pAlpha);
    vKp                 = [vK(2:end);vK(1)];

    %% 5. Backward simulation
    % Set the space
    mEV                 = zeros(size(vGridA2,1),size(vGridZ,1),size(vGridA,1));

    % Open the TFP loop
    for iApIndex                = 1:1:size(vGridA,1)

        %% 5.1. Find the "neighbours"
        % A. Look for candidates
        Ap                                      = vGridA(iApIndex);
        iCandidateLoc                           = find(vA == Ap);

        % B. Clean "forbidden" candidates & sort
        iCandidateLoc(iCandidateLoc<pBurnIn)    = [];
        iCandidateLoc(iCandidateLoc>pT)         = [];
        iCandidate                              = vK(iCandidateLoc);
        [iCandidate, iIndex]                    = sort(iCandidate);
        iCandidateLoc                           = iCandidateLoc(iIndex);

        % C. Extrapolation setting
        iEdges                                  = [-Inf; iCandidate; Inf];
        iBinIndices                             = discretize(vKp, iEdges);
        iKLow                                   = iBinIndices -1;
        iKLow(iKLow < 1)                        = 1;
        iKLow(iKLow >= length(iIndex))          = length(iIndex)-1;
        iKHigh                                  = iKLow + 1;
        iIndLow                                 = iCandidateLoc(iKLow);
        iIndHigh                                = iCandidateLoc(iKHigh);
        iWeightLow                              = (vK(iIndLow) - vKp) ./ (vK(iIndHigh) - vK(iIndLow));
        iWeightLow(iWeightLow < 0)              = 0;
        iWeightLow(iWeightLow > 1)              = 1;

        % D. Extrapolate interest rates
        iRLow                                   = pAlpha * Ap * vKtoL(iIndLow).^(pAlpha-1)-pDelta;
        iRHigh                                  = pAlpha * Ap * vKtoL(iIndHigh).^(pAlpha-1)-pDelta;

        % E. Open the skill shock loop (dimensions: wealth, time)
        iKtoLLow                                = repmat(vKtoL(iIndLow)',size(vGridA2,1),1);
        iKtoLHigh                               = repmat(vKtoL(iIndHigh)',size(vGridA2,1),1);
        ia                                      = repmat(vGridA2,1,pRequiredTime);

        for iZIndex             = 1:1:size(vGridZ,1)
            
            %% 5.2. Obtain the EV components
            % A. Labour shock
            iZ                  = repmat(vGridZ(iZIndex),size(vGridA2,1),pRequiredTime);

            % B. Policy functions: Initial guesses
            vCLow               = squeeze(mPolicyC(:,iZIndex,iIndLow,:));
            vCHigh              = squeeze(mPolicyC(:,iZIndex,iIndHigh,:));

            % C. Generate labour responses and adjustment costs
            iNLow               = (((1-pAlpha)*Ap *iKtoLLow.^(pAlpha) .* iZ) ./ (vCLow * pEta)).^(pChi);
            iNHigh              = (((1-pAlpha)*Ap *iKtoLHigh.^(pAlpha) .* iZ) ./ (vCHigh * pEta)).^(pChi);
            iPsi2Low            = pMu / 2 * (1 - (iap.^2./ia));

            % D. Generate the lower and upper expected value function
            iEVLow              = (1 + repmat(iRLow',size(vGridA2,1),1)-
            

        % Close the skill shock loop
        end
        % Close the TFP loop
    end


% End the outer loops
end 
toc;

%% Save the results


end 